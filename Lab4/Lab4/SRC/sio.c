/****************************************************************************

    sio.c - простейший драйвер последовательного канала
            для учебного стенда SDK-1.1

    (C) sio.c, Ключев А.О.  2007 г.

Это свободная программа; вы можете повторно распространять ее и/или
модифицировать ее в соответствии с Универсальной Общественной
Лицензией GNU, опубликованной Фондом Свободного ПО; либо версии 2,
либо (по вашему выбору) любой более поздней версии.

Эта программа распространяется в надежде, что она будет полезной,
но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемых гарантий
КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ.  Для
получения подробных сведений смотрите Универсальную Общественную
Лицензию GNU.

Вы должны были получить копию Универсальной Общественной Лицензии
GNU вместе с этой программой; если нет, напишите по адресу: Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA

----------------------------------------------------------------------------
Россия, Санкт-Петербург, кафедра вычислительной техники СПбГУИТМО 
e-mail: kluchev@d1.ifmo.ru

****************************************************************************/
#include "aduc812.h"
#include "sio.h"
#include "led.h"
#include "queue.h"

#define round(x) ((int)((x)+0.5))


//выделить в заголовочный
extern TQueue RFIFO;
extern TQueue WFIFO;
void SIO_ISR( void ) __interrupt ( 4 );

/*
Драйвер последовательного канала, организованного по опросу, должен содержать три
функции: 
	функция инициализации UART, 
	функция передачи и 
	приема байта данных поUART.
Драйвер последовательного канала по прерыванию состоит из: 
	функции инициализации UART, 
	обработчика прерывания от UART, 
	циклических буферов чтения и записи, 
	API-функций: 
		чтения байта из последовательного канала 
		записи байта в последовательный канал. 
Взаимодействие обработчика и API-функций осуществляется только через буфер.
*/


//////////////////////// SetVector //////////////////////////
// Функция, устанавливающая вектор прерывания в пользовательской таблице
// прерываний.
// Вход: Vector - адрес обработчика прерывания,
// Address - вектор пользовательской таблицы прерываний.
// Выход: нет.
// Результат: нет.
//////////////////////////////////////////////////////////////
void SetVector(unsigned char xdata * Address, void * Vector)
{
	unsigned char xdata * TmpVector; // Временная переменная
	// Первым байтом по указанному адресу записывается
	// код команды передачи управления ljmp, равный 0x02
	*Address = 0x02;
	// Далее записывается адрес перехода Vector
	TmpVector = (unsigned char xdata *) (Address + 1);
	*TmpVector = (unsigned char) ((unsigned short)Vector >> 8);
	++TmpVector;
	*TmpVector = (unsigned char) Vector;
	// Таким образом, по адресу Address теперь
	// располагается инструкция ljmp Vector
}



/**----------------------------------------------------------------------------
                        init_sio()
-------------------------------------------------------------------------------
Инициализирует последовательный канал на заданной скорости. Использует таймер 1

Вход:       char speed - скорость. Задается константами, описанными в 
                заголовочном файле sio.h
            bit sdouble - дублирование скорости: 0 - не дублировать скорость,
                заданную аргументом speed; 1 - дублировать.
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void init_sio( unsigned char speed )
{
    TH1       =  speed; //Хранит автоперезагружаемое значение
    //TMOD     |=  0x20; //Таймер 1 будет работать в режиме autoreload
	TMOD = TMOD & ~(T1_GATE | T1_CT | T1_M0 ) | T1_M1; //Таймер 1 будет работать в режиме autoreload
    TCON     |=  0x40; //Запуск таймера 1
	//TR1=0x1;
    SCON      =  0x50; //Настройки последовательного канала
	//SetVector( 0x2023, (void*) SIO_ISR );
	//ET1=0;//запретить прерывания от таймераъыы
	ES=0;	//Запрещение прерываний от приемопередатчика
	EA=1;	//1 – разрешены прерывания от всех источников
	//ADDCON2=
}

/*void InitSIO(char speed, bit sdouble)
{
    TH1      = speed; 
    TMOD    |= 0x20; //Таймер 1 будет работать в режиме autoreload

    if(sdouble)
        PCON|=0x80;//Если sdouble==1, то скорость удваивается
    else 
        PCON&=~0x80;

    TCON    |= 0x40; //Запуск таймера 1
    SCON     = 0x50; //Настройки последовательного канала
    ES       = 0;    //Запрещение прерываний от приемопередатчика
}
*/
volatile /*static*/ char isTransmitting = 0;




//////////////////////// SIO_ISR //////////////////////////////
// Обработчик прерывания UART.
// Вход: нет.
// Выход: нет.
// Результат: нет.
//////////////////////////////////////////////////////////////
/*  void SIO_ISR( void ) __interrupt ( SI0_VECTOR ){

	if(TI){
		// Передача байта
		// Читаем WFIFO (буфер передачи) и записываем его в SBUF
		//leds(0xF0);
		if(!isEmpty(&WFIFO)){
			isTransmitting = 1;
			SBUF = Pop(&WFIFO);
			//while( TI || !isEmpty(&WFIFO));//передача последнего байта из очереди может затянуться	
			isTransmitting = 0;
			
		} else{
			isTransmitting = 0;
		}
		TI=0;
	}
	if(RI){
		// Прием байта
		// Читаем SBUF и записываем его в RFIFO (буфер приема)
		//leds(0x0F);
		Push(&RFIFO, SBUF);
		RI=0;
	}
} */
 



/**----------------------------------------------------------------------------
                        wsio
-------------------------------------------------------------------------------
Отправляет символ по последовательному каналу

Вход:       unsigned char c - символ, который нужно отправить
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
/* void WriteUART( unsigned char c )
{
	char wasEmpty = isEmpty(&WFIFO);
	Push(&WFIFO, c);
    if(wasEmpty){
		TI=1;
	}
} */

/**----------------------------------------------------------------------------
                        rsio()
-------------------------------------------------------------------------------
Дожидается приема символа из последовательного канала и возвращает его.

Вход:       нет
Выход:      нет
Результат:  принятый символ
----------------------------------------------------------------------------- */
/* unsigned char ReadUART(void)
{
    if(!isEmpty(&RFIFO)){
		return Pop(&RFIFO);
	}
	//else
		//return;
		//return -1;
}  */


/*-------------------------------------------------------------
Функция передачи байта данных в последовательный канал для Fujitsu BM90F590.
Если в передаваемом буфере нет свободного места, то блокировки не происходит.
data - передаваемый байт
результат OK, если данные положены в передаваемый буфер
------------------------------------------------------------ */
/*ERRCODE WriteSerial( BYTE data )
{
//если исходящий буфер переполнен, возвращаем ошибку
if ( tx_count>=TX_FIFO_SIZE ) return ERR_SERIAL_TXFULL;
USR0 &= ~0x04;
tx_buf[(tx_start+tx_count)&(TX_FIFO_SIZE-1)] = data;
++tx_count;
USR0 |= 0x04;
return OK;
}*/
/*-------------------------------------------------------------
Обработчик прерываний по передаче байта по последовательному каналу.
------------------------------------------------------------ */
/*__interrupt void Serial0TxHandler(void)
{
if ( USR0&0x10 ) {
if ( tx_count ) {
UODR0 = tx_buf[tx_start&(TX_FIFO_SIZE-1)];
--tx_count;
++tx_start; } else
USR0 &= ~0x04;
}
}*/




/*void init_sio2( unsigned int baud )
{
	if(baud>9600){
		//if(baud>28800)
		
		PCON |= SMOD;
		TH1 = 0x100 - CPU_FREQ*2/32/12/baud;
		leds(0x100 - CPU_FREQ*2/32/12/baud);
	}
	else{
		PCON &= ~SMOD;
		TH1 = 0x100 - CPU_FREQ/32/12/baud;
		
		TH1 = 0x100 - TIMER_FREQ/32/baud;
	}
	
	
    //TH1       =  speed; //Хранит автоперезагружаемое значение
    //TMOD     |=  0x20; //Таймер 1 будет работать в режиме autoreload
	
	TMOD = TMOD & ~(T1_GATE | T1_CT | T1_M0 ) | T1_M1; //Таймер 1 будет работать в режиме autoreload
	
    //TCON     |=  0x40; //Запуск таймера 1
	TR1=0x1;
    SCON      =  0x50; //Настройки последовательного канала
	//ES        =  0;    //Запрещение прерываний от приемопередатчика
}
*/

/*void interrupt_exchange( unsigned char speed ){}*/
/*void polling( unsigned char speed ){}*/

/**----------------------------------------------------------------------------
                        RSioStat()
-------------------------------------------------------------------------------
Возвращает ненулевое значение, если буфер приема не пуст

Вход:       нет
Выход:      нет
Результат:  0 - буфер приема пуст;
            1 - был принят символ
----------------------------------------------------------------------------- */


unsigned char rsiostat(void)  
{
    return RI;
}


/**----------------------------------------------------------------------------
                        wsio
-------------------------------------------------------------------------------
Отправляет символ по последовательному каналу

Вход:       unsigned char c - символ, который нужно отправить
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */

void wsio( unsigned char c )
{
    SBUF = c;
    TI   = 0;
    while( !TI );
}

/**----------------------------------------------------------------------------
                        rsio()
-------------------------------------------------------------------------------
Дожидается приема символа из последовательного канала и возвращает его.

Вход:       нет
Выход:      нет
Результат:  принятый символ
----------------------------------------------------------------------------- */
unsigned char rsio(void)
{
    while( !RI );
    RI = 0;
    return SBUF;
}


/**----------------------------------------------------------------------------
                        type()
-------------------------------------------------------------------------------
Выводит ASCIIZ-строку в последовательный канал

Вход:       char *str - указатель на строку
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void type(char * str)
{
	ES=0;
	
	//if(ES==0){
		while( *str ) wsio( *str++ );
	//	leds(0xAA);
	//}
	//else{
		//while( *str ) Push(&WFIFO, *str++);
	//	while( *str ) WriteUART( *str++ );
	//	leds(0xBB);
	//}
}














